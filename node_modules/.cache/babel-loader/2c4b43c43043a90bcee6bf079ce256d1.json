{"ast":null,"code":"const audioUtils = require('./audioUtils'); // for encoding audio data as PCM\n\n\nconst crypto = require('crypto'); // tot sign our pre-signed URL\n\n\nconst v4 = require('./aws-signature-v4'); // to generate our pre-signed URL\n\n\nconst marshaller = require(\"@aws-sdk/eventstream-marshaller\"); // for converting binary event stream messages to and from JSON\n\n\nconst util_utf8_node = require(\"@aws-sdk/util-utf8-node\"); // utilities for encoding and decoding UTF8\n\n\nconst mic = require('microphone-stream'); // collect microphone input as a stream of raw bytes\n// our converter between binary event streams messages and JSON\n\n\nconst eventStreamMarshaller = new marshaller.EventStreamMarshaller(util_utf8_node.toUtf8, util_utf8_node.fromUtf8); // our global variables for managing state\n\nlet languageCode;\nlet region;\nlet sampleRate;\nlet transcription = \"\";\nlet socket;\nlet micStream;\nlet socketError = false;\nlet transcribeException = false; // check to see if the browser allows mic access\n\nif (!window.navigator.mediaDevices.getUserMedia) {\n  // Use our helper method to show an error on the page\n  showError('We support the latest versions of Chrome, Firefox, Safari, and Edge. Update your browser and try your request again.'); // maintain enabled/distabled state for the start and stop buttons\n\n  toggleStartStop();\n}\n\n$('#start-button').click(function () {\n  $('#error').hide(); // hide any existing errors\n\n  toggleStartStop(true); // disable start and enable stop button\n  // set the language and region from the dropdowns\n\n  setLanguage();\n  setRegion(); // first we get the microphone input from the browser (as a promise)...\n\n  window.navigator.mediaDevices.getUserMedia({\n    video: false,\n    audio: true\n  }) // ...then we convert the mic stream to binary event stream messages when the promise resolves \n  .then(streamAudioToWebSocket).catch(function (error) {\n    showError('There was an error streaming your audio to Amazon Transcribe. Please try again.');\n    toggleStartStop();\n  });\n});\n\nlet streamAudioToWebSocket = function (userMediaStream) {\n  //let's get the mic input from the browser, via the microphone-stream module\n  micStream = new mic();\n  micStream.setStream(userMediaStream); // Pre-signed URLs are a way to authenticate a request (or WebSocket connection, in this case)\n  // via Query Parameters. Learn more: https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html\n\n  let url = createPresignedUrl(); //open up our WebSocket connection\n\n  socket = new WebSocket(url);\n  socket.binaryType = \"arraybuffer\"; // when we get audio data from the mic, send it to the WebSocket if possible\n\n  socket.onopen = function () {\n    micStream.on('data', function (rawAudioChunk) {\n      // the audio stream is raw audio bytes. Transcribe expects PCM with additional metadata, encoded as binary\n      let binary = convertAudioToBinaryMessage(rawAudioChunk);\n      if (socket.OPEN) socket.send(binary);\n    });\n  }; // handle messages, errors, and close events\n\n\n  wireSocketEvents();\n};\n\nfunction setLanguage() {\n  languageCode = $('#language').find(':selected').val();\n  if (languageCode == \"en-US\" || languageCode == \"es-US\") sampleRate = 44100;else sampleRate = 8000;\n}\n\nfunction setRegion() {\n  region = $('#region').find(':selected').val();\n}\n\nfunction wireSocketEvents() {\n  // handle inbound messages from Amazon Transcribe\n  socket.onmessage = function (message) {\n    //convert the binary event stream message to JSON\n    let messageWrapper = eventStreamMarshaller.unmarshall(Buffer(message.data));\n    let messageBody = JSON.parse(String.fromCharCode.apply(String, messageWrapper.body));\n\n    if (messageWrapper.headers[\":message-type\"].value === \"event\") {\n      handleEventStreamMessage(messageBody);\n    } else {\n      transcribeException = true;\n      showError(messageBody.Message);\n      toggleStartStop();\n    }\n  };\n\n  socket.onerror = function () {\n    socketError = true;\n    showError('WebSocket connection error. Try again.');\n    toggleStartStop();\n  };\n\n  socket.onclose = function (closeEvent) {\n    micStream.stop(); // the close event immediately follows the error event; only handle one.\n\n    if (!socketError && !transcribeException) {\n      if (closeEvent.code != 1000) {\n        showError('</i><strong>Streaming Exception</strong><br>' + closeEvent.reason);\n      }\n\n      toggleStartStop();\n    }\n  };\n}\n\nlet handleEventStreamMessage = function (messageJson) {\n  let results = messageJson.Transcript.Results;\n\n  if (results.length > 0) {\n    if (results[0].Alternatives.length > 0) {\n      let transcript = results[0].Alternatives[0].Transcript; // fix encoding for accented characters\n\n      transcript = decodeURIComponent(escape(transcript)); // update the textarea with the latest result\n\n      $('#transcript').val(transcription + transcript + \"\\n\"); // if this transcript segment is final, add it to the overall transcription\n\n      if (!results[0].IsPartial) {\n        //scroll the textarea down\n        $('#transcript').scrollTop($('#transcript')[0].scrollHeight);\n        transcription += transcript + \"\\n\";\n      }\n    }\n  }\n};\n\nlet closeSocket = function () {\n  if (socket.OPEN) {\n    micStream.stop(); // Send an empty frame so that Transcribe initiates a closure of the WebSocket after submitting all transcripts\n\n    let emptyMessage = getAudioEventMessage(Buffer.from(new Buffer([])));\n    let emptyBuffer = eventStreamMarshaller.marshall(emptyMessage);\n    socket.send(emptyBuffer);\n  }\n};\n\n$('#stop-button').click(function () {\n  closeSocket();\n  toggleStartStop();\n});\n$('#reset-button').click(function () {\n  $('#transcript').val('');\n  transcription = '';\n});\n\nfunction toggleStartStop(disableStart = false) {\n  $('#start-button').prop('disabled', disableStart);\n  $('#stop-button').attr(\"disabled\", !disableStart);\n}\n\nfunction showError(message) {\n  $('#error').html('<i class=\"fa fa-times-circle\"></i> ' + message);\n  $('#error').show();\n}\n\nfunction convertAudioToBinaryMessage(audioChunk) {\n  let raw = mic.toRaw(audioChunk);\n  if (raw == null) return; // downsample and convert the raw audio bytes to PCM\n\n  let downsampledBuffer = audioUtils.downsampleBuffer(raw, sampleRate);\n  let pcmEncodedBuffer = audioUtils.pcmEncode(downsampledBuffer); // add the right JSON headers and structure to the message\n\n  let audioEventMessage = getAudioEventMessage(Buffer.from(pcmEncodedBuffer)); //convert the JSON object + headers into a binary event stream message\n\n  let binary = eventStreamMarshaller.marshall(audioEventMessage);\n  return binary;\n}\n\nfunction getAudioEventMessage(buffer) {\n  // wrap the audio data in a JSON envelope\n  return {\n    headers: {\n      ':message-type': {\n        type: 'string',\n        value: 'event'\n      },\n      ':event-type': {\n        type: 'string',\n        value: 'AudioEvent'\n      }\n    },\n    body: buffer\n  };\n}\n\nfunction createPresignedUrl() {\n  let endpoint = \"transcribestreaming.\" + region + \".amazonaws.com:8443\"; // get a preauthenticated URL that we can use to establish our WebSocket\n\n  return v4.createPresignedURL('GET', endpoint, '/stream-transcription-websocket', 'transcribe', crypto.createHash('sha256').update('', 'utf8').digest('hex'), {\n    'key': $('#access_id').val(),\n    'secret': $('#secret_key').val(),\n    'sessionToken': $('#session_token').val(),\n    'protocol': 'wss',\n    'expires': 15,\n    'region': region,\n    'query': \"language-code=\" + languageCode + \"&media-encoding=pcm&sample-rate=\" + sampleRate\n  });\n}","map":{"version":3,"sources":["/home/ec2-user/environment/myapp/src/lib/main.js"],"names":["audioUtils","require","crypto","v4","marshaller","util_utf8_node","mic","eventStreamMarshaller","EventStreamMarshaller","toUtf8","fromUtf8","languageCode","region","sampleRate","transcription","socket","micStream","socketError","transcribeException","window","navigator","mediaDevices","getUserMedia","showError","toggleStartStop","$","click","hide","setLanguage","setRegion","video","audio","then","streamAudioToWebSocket","catch","error","userMediaStream","setStream","url","createPresignedUrl","WebSocket","binaryType","onopen","on","rawAudioChunk","binary","convertAudioToBinaryMessage","OPEN","send","wireSocketEvents","find","val","onmessage","message","messageWrapper","unmarshall","Buffer","data","messageBody","JSON","parse","String","fromCharCode","apply","body","headers","value","handleEventStreamMessage","Message","onerror","onclose","closeEvent","stop","code","reason","messageJson","results","Transcript","Results","length","Alternatives","transcript","decodeURIComponent","escape","IsPartial","scrollTop","scrollHeight","closeSocket","emptyMessage","getAudioEventMessage","from","emptyBuffer","marshall","disableStart","prop","attr","html","show","audioChunk","raw","toRaw","downsampledBuffer","downsampleBuffer","pcmEncodedBuffer","pcmEncode","audioEventMessage","buffer","type","endpoint","createPresignedURL","createHash","update","digest"],"mappings":"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","sourcesContent":["const audioUtils        = require('./audioUtils');  // for encoding audio data as PCM\nconst crypto            = require('crypto'); // tot sign our pre-signed URL\nconst v4                = require('./aws-signature-v4'); // to generate our pre-signed URL\nconst marshaller        = require(\"@aws-sdk/eventstream-marshaller\"); // for converting binary event stream messages to and from JSON\nconst util_utf8_node    = require(\"@aws-sdk/util-utf8-node\"); // utilities for encoding and decoding UTF8\nconst mic               = require('microphone-stream'); // collect microphone input as a stream of raw bytes\n\n// our converter between binary event streams messages and JSON\nconst eventStreamMarshaller = new marshaller.EventStreamMarshaller(util_utf8_node.toUtf8, util_utf8_node.fromUtf8);\n\n// our global variables for managing state\nlet languageCode;\nlet region;\nlet sampleRate;\nlet transcription = \"\";\nlet socket;\nlet micStream;\nlet socketError = false;\nlet transcribeException = false;\n\n// check to see if the browser allows mic access\nif (!window.navigator.mediaDevices.getUserMedia) {\n    // Use our helper method to show an error on the page\n    showError('We support the latest versions of Chrome, Firefox, Safari, and Edge. Update your browser and try your request again.');\n\n    // maintain enabled/distabled state for the start and stop buttons\n    toggleStartStop();\n}\n\n$('#start-button').click(function () {\n    $('#error').hide(); // hide any existing errors\n    toggleStartStop(true); // disable start and enable stop button\n\n    // set the language and region from the dropdowns\n    setLanguage();\n    setRegion();\n\n    // first we get the microphone input from the browser (as a promise)...\n    window.navigator.mediaDevices.getUserMedia({\n            video: false,\n            audio: true\n        })\n        // ...then we convert the mic stream to binary event stream messages when the promise resolves \n        .then(streamAudioToWebSocket) \n        .catch(function (error) {\n            showError('There was an error streaming your audio to Amazon Transcribe. Please try again.');\n            toggleStartStop();\n        });\n});\n\nlet streamAudioToWebSocket = function (userMediaStream) {\n    //let's get the mic input from the browser, via the microphone-stream module\n    micStream = new mic();\n    micStream.setStream(userMediaStream);\n\n    // Pre-signed URLs are a way to authenticate a request (or WebSocket connection, in this case)\n    // via Query Parameters. Learn more: https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html\n    let url = createPresignedUrl();\n\n    //open up our WebSocket connection\n    socket = new WebSocket(url);\n    socket.binaryType = \"arraybuffer\";\n\n    // when we get audio data from the mic, send it to the WebSocket if possible\n    socket.onopen = function() {\n        micStream.on('data', function(rawAudioChunk) {\n            // the audio stream is raw audio bytes. Transcribe expects PCM with additional metadata, encoded as binary\n            let binary = convertAudioToBinaryMessage(rawAudioChunk);\n\n            if (socket.OPEN)\n                socket.send(binary);\n        }\n    )};\n\n    // handle messages, errors, and close events\n    wireSocketEvents();\n}\n\nfunction setLanguage() {\n    languageCode = $('#language').find(':selected').val();\n    if (languageCode == \"en-US\" || languageCode == \"es-US\")\n        sampleRate = 44100;\n    else\n        sampleRate = 8000;\n}\n\nfunction setRegion() {\n    region = $('#region').find(':selected').val();\n}\n\nfunction wireSocketEvents() {\n    // handle inbound messages from Amazon Transcribe\n    socket.onmessage = function (message) {\n        //convert the binary event stream message to JSON\n        let messageWrapper = eventStreamMarshaller.unmarshall(Buffer(message.data));\n        let messageBody = JSON.parse(String.fromCharCode.apply(String, messageWrapper.body));\n        if (messageWrapper.headers[\":message-type\"].value === \"event\") {\n            handleEventStreamMessage(messageBody);\n        }\n        else {\n            transcribeException = true;\n            showError(messageBody.Message);\n            toggleStartStop();\n        }\n    };\n\n    socket.onerror = function () {\n        socketError = true;\n        showError('WebSocket connection error. Try again.');\n        toggleStartStop();\n    };\n    \n    socket.onclose = function (closeEvent) {\n        micStream.stop();\n        \n        // the close event immediately follows the error event; only handle one.\n        if (!socketError && !transcribeException) {\n            if (closeEvent.code != 1000) {\n                showError('</i><strong>Streaming Exception</strong><br>' + closeEvent.reason);\n            }\n            toggleStartStop();\n        }\n    };\n}\n\nlet handleEventStreamMessage = function (messageJson) {\n    let results = messageJson.Transcript.Results;\n\n    if (results.length > 0) {\n        if (results[0].Alternatives.length > 0) {\n            let transcript = results[0].Alternatives[0].Transcript;\n\n            // fix encoding for accented characters\n            transcript = decodeURIComponent(escape(transcript));\n\n            // update the textarea with the latest result\n            $('#transcript').val(transcription + transcript + \"\\n\");\n\n            // if this transcript segment is final, add it to the overall transcription\n            if (!results[0].IsPartial) {\n                //scroll the textarea down\n                $('#transcript').scrollTop($('#transcript')[0].scrollHeight);\n\n                transcription += transcript + \"\\n\";\n            }\n        }\n    }\n}\n\nlet closeSocket = function () {\n    if (socket.OPEN) {\n        micStream.stop();\n\n        // Send an empty frame so that Transcribe initiates a closure of the WebSocket after submitting all transcripts\n        let emptyMessage = getAudioEventMessage(Buffer.from(new Buffer([])));\n        let emptyBuffer = eventStreamMarshaller.marshall(emptyMessage);\n        socket.send(emptyBuffer);\n    }\n}\n\n$('#stop-button').click(function () {\n    closeSocket();\n    toggleStartStop();\n});\n\n$('#reset-button').click(function (){\n    $('#transcript').val('');\n    transcription = '';\n});\n\nfunction toggleStartStop(disableStart = false) {\n    $('#start-button').prop('disabled', disableStart);\n    $('#stop-button').attr(\"disabled\", !disableStart);\n}\n\nfunction showError(message) {\n    $('#error').html('<i class=\"fa fa-times-circle\"></i> ' + message);\n    $('#error').show();\n}\n\nfunction convertAudioToBinaryMessage(audioChunk) {\n    let raw = mic.toRaw(audioChunk);\n\n    if (raw == null)\n        return;\n\n    // downsample and convert the raw audio bytes to PCM\n    let downsampledBuffer = audioUtils.downsampleBuffer(raw, sampleRate);\n    let pcmEncodedBuffer = audioUtils.pcmEncode(downsampledBuffer);\n\n    // add the right JSON headers and structure to the message\n    let audioEventMessage = getAudioEventMessage(Buffer.from(pcmEncodedBuffer));\n\n    //convert the JSON object + headers into a binary event stream message\n    let binary = eventStreamMarshaller.marshall(audioEventMessage);\n\n    return binary;\n}\n\nfunction getAudioEventMessage(buffer) {\n    // wrap the audio data in a JSON envelope\n    return {\n        headers: {\n            ':message-type': {\n                type: 'string',\n                value: 'event'\n            },\n            ':event-type': {\n                type: 'string',\n                value: 'AudioEvent'\n            }\n        },\n        body: buffer\n    };\n}\n\nfunction createPresignedUrl() {\n    let endpoint = \"transcribestreaming.\" + region + \".amazonaws.com:8443\";\n\n    // get a preauthenticated URL that we can use to establish our WebSocket\n    return v4.createPresignedURL(\n        'GET',\n        endpoint,\n        '/stream-transcription-websocket',\n        'transcribe',\n        crypto.createHash('sha256').update('', 'utf8').digest('hex'), {\n            'key': $('#access_id').val(),\n            'secret': $('#secret_key').val(),\n            'sessionToken': $('#session_token').val(),\n            'protocol': 'wss',\n            'expires': 15,\n            'region': region,\n            'query': \"language-code=\" + languageCode + \"&media-encoding=pcm&sample-rate=\" + sampleRate\n        }\n    );\n}\n"]},"metadata":{},"sourceType":"module"}