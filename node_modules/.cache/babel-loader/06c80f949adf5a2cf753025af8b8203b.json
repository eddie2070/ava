{"ast":null,"code":"const inputSampleRate = 44100;\nexport function pcmEncode(input) {\n  var offset = 0;\n  var buffer = new ArrayBuffer(input.length * 2);\n  var view = new DataView(buffer);\n\n  for (var i = 0; i < input.length; i++, offset += 2) {\n    var s = Math.max(-1, Math.min(1, input[i]));\n    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n  }\n\n  return buffer;\n}\nexport function downsampleBuffer(buffer, outputSampleRate = 16000) {\n  if (outputSampleRate === inputSampleRate) {\n    return buffer;\n  }\n\n  var sampleRateRatio = inputSampleRate / outputSampleRate;\n  var newLength = Math.round(buffer.length / sampleRateRatio);\n  var result = new Float32Array(newLength);\n  var offsetResult = 0;\n  var offsetBuffer = 0;\n\n  while (offsetResult < result.length) {\n    var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    var accum = 0,\n        count = 0;\n\n    for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n\n    result[offsetResult] = accum / count;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/home/ec2-user/environment/myapp/src/lib/audioUtils.js"],"names":["inputSampleRate","pcmEncode","input","offset","buffer","ArrayBuffer","length","view","DataView","i","s","Math","max","min","setInt16","downsampleBuffer","outputSampleRate","sampleRateRatio","newLength","round","result","Float32Array","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count"],"mappings":"AAAA,MAAMA,eAAe,GAAG,KAAxB;AAEA,OAAO,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;AAC7B,MAAIC,MAAM,GAAG,CAAb;AACA,MAAIC,MAAM,GAAG,IAAIC,WAAJ,CAAgBH,KAAK,CAACI,MAAN,GAAe,CAA/B,CAAb;AACA,MAAIC,IAAI,GAAG,IAAIC,QAAJ,CAAaJ,MAAb,CAAX;;AACA,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,KAAK,CAACI,MAA1B,EAAkCG,CAAC,IAAIN,MAAM,IAAI,CAAjD,EAAoD;AAChD,QAAIO,CAAC,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAC,CAAV,EAAaD,IAAI,CAACE,GAAL,CAAS,CAAT,EAAYX,KAAK,CAACO,CAAD,CAAjB,CAAb,CAAR;AACAF,IAAAA,IAAI,CAACO,QAAL,CAAcX,MAAd,EAAsBO,CAAC,GAAG,CAAJ,GAAQA,CAAC,GAAG,MAAZ,GAAqBA,CAAC,GAAG,MAA/C,EAAuD,IAAvD;AACH;;AACD,SAAON,MAAP;AACH;AAED,OAAO,SAASW,gBAAT,CAA0BX,MAA1B,EAAkCY,gBAAgB,GAAG,KAArD,EAA4D;AAC/D,MAAIA,gBAAgB,KAAKhB,eAAzB,EAA0C;AACtC,WAAOI,MAAP;AACH;;AAED,MAAIa,eAAe,GAAGjB,eAAe,GAAGgB,gBAAxC;AACA,MAAIE,SAAS,GAAGP,IAAI,CAACQ,KAAL,CAAWf,MAAM,CAACE,MAAP,GAAgBW,eAA3B,CAAhB;AACA,MAAIG,MAAM,GAAG,IAAIC,YAAJ,CAAiBH,SAAjB,CAAb;AACA,MAAII,YAAY,GAAG,CAAnB;AACA,MAAIC,YAAY,GAAG,CAAnB;;AACA,SAAOD,YAAY,GAAGF,MAAM,CAACd,MAA7B,EAAqC;AACjC,QAAIkB,gBAAgB,GAAGb,IAAI,CAACQ,KAAL,CAAW,CAACG,YAAY,GAAG,CAAhB,IAAqBL,eAAhC,CAAvB;AACA,QAAIQ,KAAK,GAAG,CAAZ;AAAA,QACAC,KAAK,GAAG,CADR;;AAEA,SAAK,IAAIjB,CAAC,GAAGc,YAAb,EAA2Bd,CAAC,GAAGe,gBAAJ,IAAwBf,CAAC,GAAGL,MAAM,CAACE,MAA9D,EAAsEG,CAAC,EAAvE,EAA2E;AACvEgB,MAAAA,KAAK,IAAIrB,MAAM,CAACK,CAAD,CAAf;AACAiB,MAAAA,KAAK;AACR;;AACDN,IAAAA,MAAM,CAACE,YAAD,CAAN,GAAuBG,KAAK,GAAGC,KAA/B;AACAJ,IAAAA,YAAY;AACZC,IAAAA,YAAY,GAAGC,gBAAf;AACF;;AACD,SAAOJ,MAAP;AACJ","sourcesContent":["const inputSampleRate = 44100;\n\nexport function pcmEncode(input) {\n    var offset = 0;\n    var buffer = new ArrayBuffer(input.length * 2);\n    var view = new DataView(buffer);\n    for (var i = 0; i < input.length; i++, offset += 2) {\n        var s = Math.max(-1, Math.min(1, input[i]));\n        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n    }\n    return buffer;\n}\n\nexport function downsampleBuffer(buffer, outputSampleRate = 16000) {\n    if (outputSampleRate === inputSampleRate) {\n        return buffer;\n    }\n\n    var sampleRateRatio = inputSampleRate / outputSampleRate;\n    var newLength = Math.round(buffer.length / sampleRateRatio);\n    var result = new Float32Array(newLength);\n    var offsetResult = 0;\n    var offsetBuffer = 0;\n    while (offsetResult < result.length) {\n        var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n        var accum = 0,\n        count = 0;\n        for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n            accum += buffer[i];\n            count++;\n        }\n        result[offsetResult] = accum / count;\n        offsetResult++;\n        offsetBuffer = nextOffsetBuffer;\n     }\n     return result;\n}"]},"metadata":{},"sourceType":"module"}