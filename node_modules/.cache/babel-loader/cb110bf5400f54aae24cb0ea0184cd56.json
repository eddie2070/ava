{"ast":null,"code":"const audioUtils = require('./audioUtils'); // for encoding audio data as PCM\n\n\nconst crypto = require('crypto'); // tot sign our pre-signed URL\n\n\nconst v4 = require('./aws-signature-v4'); // to generate our pre-signed URL\n\n\nconst marshaller = require(\"@aws-sdk/eventstream-marshaller\"); // for converting binary event stream messages to and from JSON\n\n\nconst util_utf8_node = require(\"@aws-sdk/util-utf8-node\"); // utilities for encoding and decoding UTF8\n\n\nconst mic = require('microphone-stream'); // collect microphone input as a stream of raw bytes\n\n\nconst $ = require('jquery');\n\nconst AWS = require('aws-sdk'); // our converter between binary event streams messages and JSON\n\n\nconst eventStreamMarshaller = new marshaller.EventStreamMarshaller(util_utf8_node.toUtf8, util_utf8_node.fromUtf8);\nvar lexruntime = new AWS.LexRuntime(); // our global variables for managing state\n\nlet languageCode;\nlet region;\nlet sampleRate;\nlet transcription = \"\";\nlet socket;\nlet micStream;\nlet socketError = false;\nlet transcribeException = false; // check to see if the browser allows mic access\n\nif (!window.navigator.mediaDevices.getUserMedia) {\n  // Use our helper method to show an error on the page\n  showError('We support the latest versions of Chrome, Firefox, Safari, and Edge. Update your browser and try your request again.'); // maintain enabled/distabled state for the start and stop buttons\n\n  toggleStartStop();\n}\n\nexport function startbutton() {\n  console.log(\"buttontest1\");\n  toggleStartStop(true); // disable start and enable stop button\n  // set the language and region from the dropdowns\n\n  setLanguage();\n  setRegion(); // first we get the microphone input from the browser (as a promise)...\n  //window.navigator.mediaDevices.getUserMedia({ video: false, audio: true }).then(streamAudioToWebSocket)\n  // ...then we convert the mic stream to binary event stream messages when the promise resolves \n  //.catch(function (error) {\n  //    console.log(\"ERROR\");\n  //    showError('There was an error streaming your audio to Amazon Transcribe. Please try again.');\n  //    toggleStartStop();\n  //});\n\n  streamAudioToWebSocket();\n}\n; //LEX INIT\n\nvar stl = function sendToLex(message) {\n  var params = {\n    botAlias: 'dev',\n\n    /* required, has to be '$LATEST' */\n    botName: 'CoffeeBot',\n\n    /* required, the name of you bot */\n    inputText: message,\n\n    /* required, your text */\n    userId: 'USER'\n    /* required, arbitrary identifier */\n\n  };\n  lexruntime.postText(params, (err, data) => {\n    if (err) {// TODO SHOW ERROR ON MESSAGES\n    }\n\n    if (data) {\n      this.showResponse(data);\n    }\n  });\n}; //LEX END INIT\n\n\nlet streamAudioToWebSocket = function (userMediaStream) {\n  //let's get the mic input from the browser, via the microphone-stream module\n  //console.log(\"streamAudioToWebSocket\");\n  window.navigator.mediaDevices.getUserMedia({\n    video: false,\n    audio: true\n  }).then(stream => {\n    micStream = new mic();\n    micStream.setStream(stream); //console.log(\"buttontest2\");\n    // Pre-signed URLs are a way to authenticate a request (or WebSocket connection, in this case)\n    // via Query Parameters. Learn more: https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html\n\n    let url = createPresignedUrl(); //open up our WebSocket connection\n\n    socket = new WebSocket(url); //console.log(\"socket return: \", socket);\n\n    socket.binaryType = \"arraybuffer\"; // when we get audio data from the mic, send it to the WebSocket if possible\n\n    socket.onopen = function () {\n      //console.log(\"micstream.on test2a\");\n      micStream.on('data', chunk => {\n        //console.log(\"micstream.on test2b\");\n        var raw = mic.toRaw(chunk); //console.log(\"micstream.on test3\");\n\n        if (raw == null) {\n          return;\n        }\n\n        console.log(\"binary1: \");\n        var binary = convertAudioToBinaryMessage(raw); //console.log(\"binary2: \", binary);\n\n        if (socket.OPEN) {\n          console.log(\"socket\");\n          socket.send(binary);\n        }\n\n        ;\n      }); //        micStream.on('data', function(rawAudioChunk) {\n      //                console.log(\"rawAudioChunk:\", rawAudioChunk);\n      //            // the audio stream is raw audio bytes. Transcribe expects PCM with additional metadata, encoded as binary\n      //                let binary = convertAudioToBinaryMessage(rawAudioChunk);\n      //                console.log(\"binary2: \", binary);\n    };\n\n    socket.onerror = function () {\n      socketError = true;\n      showError('WebSocket connection error. Try again.');\n      console.log(\"WebSocket connection error. Try again.\");\n      toggleStartStop();\n    };\n\n    socket.onclose = function (closeEvent) {\n      //console.log(\"micStream.stop: \", closeEvent);\n      micStream.stop();\n    }; // handle messages, errors, and close events\n\n\n    wireSocketEvents();\n  });\n};\n\nfunction setLanguage() {\n  //languageCode = $('#language').find(':selected').val();\n  languageCode = \"en-US\";\n  if (languageCode == \"en-US\" || languageCode == \"es-US\") sampleRate = 44100;else sampleRate = 8800;\n}\n\nfunction setRegion() {\n  //region = $('#region').find(':selected').val();\n  region = 'us-east-1';\n}\n\nfunction wireSocketEvents() {\n  //console.log(\"wiresocketEvent test\");\n  // handle inbound messages from Amazon Transcribe\n  socket.onmessage = function (message) {\n    //convert the binary event stream message to JSON\n    //console.log(\"message.data :\", message.data);\n    let messageWrapper = eventStreamMarshaller.unmarshall(Buffer(message.data)); //console.log(\"messageWrapper\", messageWrapper);\n\n    let messageBody = JSON.parse(String.fromCharCode.apply(String, messageWrapper.body)); //console.log(\"headers: \", messageWrapper.headers[\":message-type\"].value);\n\n    if (messageWrapper.headers[\":message-type\"].value === \"event\") {\n      //console.log(\"messageWrapper.headers\");\n      handleEventStreamMessage(messageBody);\n    } else {\n      console.log(\"messageWrapper.error\");\n      transcribeException = true;\n      showError(messageBody.Message);\n      toggleStartStop();\n    }\n  };\n\n  socket.onerror = function () {\n    socketError = true;\n    showError('WebSocket connection error. Try again.');\n    console.log(\"WebSocket connection error. Try again.\");\n    toggleStartStop();\n  };\n\n  socket.onclose = function (closeEvent) {\n    console.log(\"micStream.stop: \", closeEvent);\n    micStream.stop(); // the close event immediately follows the error event; only handle one.\n\n    if (!socketError && !transcribeException) {\n      if (closeEvent.code != 1000) {\n        showError('</i><strong>Streaming Exception</strong><br>' + closeEvent.reason);\n      }\n\n      toggleStartStop();\n    }\n  };\n}\n\nlet handleEventStreamMessage = function (messageJson) {\n  let results = messageJson.Transcript.Results;\n\n  if (results.length > 0) {\n    if (results[0].Alternatives.length > 0) {\n      let transcript = results[0].Alternatives[0].Transcript; // fix encoding for accented characters\n\n      transcript = decodeURIComponent(escape(transcript));\n      console.log('transcript: ', transcript); // update the textarea with the latest result\n\n      $('#transcript').val(transcription + transcript + \"\\n\"); // if this transcript segment is final, add it to the overall transcription\n\n      if (!results[0].IsPartial) {\n        //scroll the textarea down\n        console.log('transcript[0]:', results[0]); //HERE TO SEND TO LEX\n\n        closeSocket();\n        stl(results[0]);\n        $('#transcript').scrollTop($('#transcript')[0].scrollHeight);\n        transcription += transcript + \"\\n\";\n      }\n    }\n  }\n};\n\nlet closeSocket = function () {\n  if (socket.OPEN) {\n    micStream.stop(); // Send an empty frame so that Transcribe initiates a closure of the WebSocket after submitting all transcripts\n\n    let emptyMessage = getAudioEventMessage(Buffer.from(new Buffer([])));\n    let emptyBuffer = eventStreamMarshaller.marshall(emptyMessage);\n    socket.send(emptyBuffer);\n  } else console.log('already closed');\n};\n\nexport function stopbutton() {\n  closeSocket();\n  toggleStartStop();\n}\n;\nexport function resetbutton() {\n  $('#transcript').val('');\n  transcription = '';\n}\n;\n\nfunction toggleStartStop(disableStart = false) {\n  $('#start-button').prop('disabled', disableStart);\n  $('#stop-button').attr(\"disabled\", !disableStart);\n}\n\nfunction showError(message) {\n  $('#error').html('<i class=\"fa fa-times-circle\"></i> ' + message);\n  $('#error').show();\n}\n\nfunction convertAudioToBinaryMessage(audioChunk) {\n  console.log(\"start convertAudioToBinaryMessage\");\n  let raw = mic.toRaw(audioChunk);\n\n  if (raw == null) {\n    console(\"raw null\");\n    return;\n  }\n\n  console.log(\"raw not null\"); // downsample and convert the raw audio bytes to PCM\n\n  let downsampledBuffer = audioUtils.downsampleBuffer(raw, sampleRate);\n  let pcmEncodedBuffer = audioUtils.pcmEncode(downsampledBuffer); // add the right JSON headers and structure to the message\n\n  let audioEventMessage = getAudioEventMessage(Buffer.from(pcmEncodedBuffer)); //console.log('audioeventmessage: ', audioEventMessage);\n  //convert the JSON object + headers into a binary event stream message\n\n  let binary = eventStreamMarshaller.marshall(audioEventMessage); //console.log(\"binary :\", binary);\n\n  return binary;\n}\n\nfunction getAudioEventMessage(buffer) {\n  // wrap the audio data in a JSON envelope\n  return {\n    headers: {\n      ':message-type': {\n        type: 'string',\n        value: 'event'\n      },\n      ':event-type': {\n        type: 'string',\n        value: 'AudioEvent'\n      }\n    },\n    body: buffer\n  };\n}\n\nfunction createPresignedUrl() {\n  let endpoint = \"transcribestreaming.\" + region + \".amazonaws.com:8443\"; // get a preauthenticated URL that we can use to establish our WebSocket\n\n  return v4.createPresignedURL('GET', endpoint, '/stream-transcription-websocket', 'transcribe', crypto.createHash('sha256').update('', 'utf8').digest('hex'), {\n    'key': $('#access_id').val(),\n    'secret': $('#secret_key').val(),\n    'sessionToken': $('#session_token').val(),\n    'protocol': 'wss',\n    'expires': 15,\n    'region': region,\n    'query': \"language-code=\" + languageCode + \"&media-encoding=pcm&sample-rate=\" + sampleRate\n  });\n}","map":{"version":3,"sources":["/home/ec2-user/environment/myapp/src/lib/main.js"],"names":["audioUtils","require","crypto","v4","marshaller","util_utf8_node","mic","$","AWS","eventStreamMarshaller","EventStreamMarshaller","toUtf8","fromUtf8","lexruntime","LexRuntime","languageCode","region","sampleRate","transcription","socket","micStream","socketError","transcribeException","window","navigator","mediaDevices","getUserMedia","showError","toggleStartStop","startbutton","console","log","setLanguage","setRegion","streamAudioToWebSocket","stl","sendToLex","message","params","botAlias","botName","inputText","userId","postText","err","data","showResponse","userMediaStream","video","audio","then","stream","setStream","url","createPresignedUrl","WebSocket","binaryType","onopen","on","chunk","raw","toRaw","binary","convertAudioToBinaryMessage","OPEN","send","onerror","onclose","closeEvent","stop","wireSocketEvents","onmessage","messageWrapper","unmarshall","Buffer","messageBody","JSON","parse","String","fromCharCode","apply","body","headers","value","handleEventStreamMessage","Message","code","reason","messageJson","results","Transcript","Results","length","Alternatives","transcript","decodeURIComponent","escape","val","IsPartial","closeSocket","scrollTop","scrollHeight","emptyMessage","getAudioEventMessage","from","emptyBuffer","marshall","stopbutton","resetbutton","disableStart","prop","attr","html","show","audioChunk","downsampledBuffer","downsampleBuffer","pcmEncodedBuffer","pcmEncode","audioEventMessage","buffer","type","endpoint","createPresignedURL","createHash","update","digest"],"mappings":"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","sourcesContent":["const audioUtils        = require('./audioUtils');  // for encoding audio data as PCM\nconst crypto            = require('crypto'); // tot sign our pre-signed URL\nconst v4                = require('./aws-signature-v4'); // to generate our pre-signed URL\nconst marshaller        = require(\"@aws-sdk/eventstream-marshaller\"); // for converting binary event stream messages to and from JSON\nconst util_utf8_node    = require(\"@aws-sdk/util-utf8-node\"); // utilities for encoding and decoding UTF8\nconst mic               = require('microphone-stream'); // collect microphone input as a stream of raw bytes\nconst $                 = require('jquery');\nconst AWS                 = require('aws-sdk');\n\n// our converter between binary event streams messages and JSON\nconst eventStreamMarshaller = new marshaller.EventStreamMarshaller(util_utf8_node.toUtf8, util_utf8_node.fromUtf8);\nvar lexruntime = new AWS.LexRuntime();\n    \n// our global variables for managing state\nlet languageCode;\nlet region;\nlet sampleRate;\nlet transcription = \"\";\nlet socket;\nlet micStream;\nlet socketError = false;\nlet transcribeException = false;\n\n\n\n// check to see if the browser allows mic access\nif (!window.navigator.mediaDevices.getUserMedia) {\n    // Use our helper method to show an error on the page\n    showError('We support the latest versions of Chrome, Firefox, Safari, and Edge. Update your browser and try your request again.');\n\n    // maintain enabled/distabled state for the start and stop buttons\n    toggleStartStop();\n}\n\n    export function startbutton () {\n    console.log(\"buttontest1\");\n    toggleStartStop(true); // disable start and enable stop button\n\n    // set the language and region from the dropdowns\n    setLanguage();\n    setRegion();\n\n    // first we get the microphone input from the browser (as a promise)...\n    //window.navigator.mediaDevices.getUserMedia({ video: false, audio: true }).then(streamAudioToWebSocket)\n        // ...then we convert the mic stream to binary event stream messages when the promise resolves \n        //.catch(function (error) {\n        //    console.log(\"ERROR\");\n        //    showError('There was an error streaming your audio to Amazon Transcribe. Please try again.');\n        //    toggleStartStop();\n        //});\n        streamAudioToWebSocket();\n};\n\n//LEX INIT\nvar stl = function sendToLex(message) {\n\n\n    var params = {\n        botAlias: 'dev', /* required, has to be '$LATEST' */\n        botName: 'CoffeeBot', /* required, the name of you bot */\n        inputText: message, /* required, your text */\n        userId: 'USER', /* required, arbitrary identifier */\n    }\n\n    lexruntime.postText(params, (err, data) => {\n            if(err) {\n                // TODO SHOW ERROR ON MESSAGES\n            }\n            if (data) {\n                this.showResponse(data)\n            }\n        })\n}\n\n//LEX END INIT\n\nlet streamAudioToWebSocket = function (userMediaStream) {\n    //let's get the mic input from the browser, via the microphone-stream module\n    //console.log(\"streamAudioToWebSocket\");\n    window.navigator.mediaDevices.getUserMedia({ video: false, audio: true }).then((stream) => {\n    micStream = new mic();\n    micStream.setStream(stream);\n    //console.log(\"buttontest2\");\n\n    // Pre-signed URLs are a way to authenticate a request (or WebSocket connection, in this case)\n    // via Query Parameters. Learn more: https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html\n    let url = createPresignedUrl();\n\n    //open up our WebSocket connection\n        socket = new WebSocket(url);\n    //console.log(\"socket return: \", socket);\n    socket.binaryType = \"arraybuffer\";\n\n    // when we get audio data from the mic, send it to the WebSocket if possible\n    socket.onopen = function() {\n        //console.log(\"micstream.on test2a\");\n        micStream.on('data', (chunk) => {\n          //console.log(\"micstream.on test2b\");\n          var raw = mic.toRaw(chunk);\n          //console.log(\"micstream.on test3\");\n          if (raw == null) {\n            return;\n          }\n        console.log(\"binary1: \");\n          var binary = convertAudioToBinaryMessage(raw);\n          //console.log(\"binary2: \", binary);\n            \n                if (socket.OPEN) {\n                console.log(\"socket\");\n                socket.send(binary);\n            };\n        });\n//        micStream.on('data', function(rawAudioChunk) {\n//                console.log(\"rawAudioChunk:\", rawAudioChunk);\n//            // the audio stream is raw audio bytes. Transcribe expects PCM with additional metadata, encoded as binary\n//                let binary = convertAudioToBinaryMessage(rawAudioChunk);\n//                console.log(\"binary2: \", binary);\n                \n\n        };\n        \n        socket.onerror = function () {\n        socketError = true;\n        showError('WebSocket connection error. Try again.');\n        console.log(\"WebSocket connection error. Try again.\");\n        toggleStartStop();\n    };\n    \n        socket.onclose = function (closeEvent) {\n        //console.log(\"micStream.stop: \", closeEvent);\n        micStream.stop();\n        }\n\n    // handle messages, errors, and close events\n    wireSocketEvents();\n    });\n}\n\nfunction setLanguage() {\n    //languageCode = $('#language').find(':selected').val();\n    languageCode = \"en-US\" \n    if (languageCode == \"en-US\" || languageCode == \"es-US\")\n        sampleRate = 44100;\n    else\n        sampleRate = 8800;\n}\n\nfunction setRegion() {\n    //region = $('#region').find(':selected').val();\n    region = 'us-east-1';\n}\n\nfunction wireSocketEvents() {\n    //console.log(\"wiresocketEvent test\");\n    // handle inbound messages from Amazon Transcribe\n    socket.onmessage = function (message) {\n        //convert the binary event stream message to JSON\n        //console.log(\"message.data :\", message.data);\n        let messageWrapper = eventStreamMarshaller.unmarshall(Buffer(message.data));\n        //console.log(\"messageWrapper\", messageWrapper);\n        let messageBody = JSON.parse(String.fromCharCode.apply(String, messageWrapper.body));\n        //console.log(\"headers: \", messageWrapper.headers[\":message-type\"].value);\n        if (messageWrapper.headers[\":message-type\"].value === \"event\") {\n            //console.log(\"messageWrapper.headers\");\n            handleEventStreamMessage(messageBody);\n        }\n        else {\n            console.log(\"messageWrapper.error\");\n            transcribeException = true;\n            showError(messageBody.Message);\n            toggleStartStop();\n        }\n    };\n\n    socket.onerror = function () {\n        socketError = true;\n        showError('WebSocket connection error. Try again.');\n        console.log(\"WebSocket connection error. Try again.\");\n        toggleStartStop();\n    };\n    \n    socket.onclose = function (closeEvent) {\n        console.log(\"micStream.stop: \", closeEvent);\n        micStream.stop();\n        \n        // the close event immediately follows the error event; only handle one.\n        if (!socketError && !transcribeException) {\n            if (closeEvent.code != 1000) {\n                showError('</i><strong>Streaming Exception</strong><br>' + closeEvent.reason);\n            }\n            toggleStartStop();\n        }\n    };\n}\n\nlet handleEventStreamMessage = function (messageJson) {\n    let results = messageJson.Transcript.Results;\n\n\n    if (results.length > 0) {\n        if (results[0].Alternatives.length > 0) {\n            let transcript = results[0].Alternatives[0].Transcript;\n\n            // fix encoding for accented characters\n            transcript = decodeURIComponent(escape(transcript));\n            console.log('transcript: ', transcript);\n\n            // update the textarea with the latest result\n            $('#transcript').val(transcription + transcript + \"\\n\");\n\n            // if this transcript segment is final, add it to the overall transcription\n            if (!results[0].IsPartial) {\n                //scroll the textarea down\n                console.log('transcript[0]:', results[0]);\n                //HERE TO SEND TO LEX\n                closeSocket();\n                stl(results[0]);\n                \n                $('#transcript').scrollTop($('#transcript')[0].scrollHeight);\n\n                transcription += transcript + \"\\n\";\n            }\n        }\n    }\n}\n\nlet closeSocket = function () {\n    if (socket.OPEN) {\n        micStream.stop();\n\n        // Send an empty frame so that Transcribe initiates a closure of the WebSocket after submitting all transcripts\n        let emptyMessage = getAudioEventMessage(Buffer.from(new Buffer([])));\n        let emptyBuffer = eventStreamMarshaller.marshall(emptyMessage);\n        socket.send(emptyBuffer);\n    }\n    else console.log('already closed');\n}\n\nexport function stopbutton () {\n    closeSocket();\n    toggleStartStop();\n};\n\nexport function resetbutton () {\n    $('#transcript').val('');\n    transcription = '';\n};\n\nfunction toggleStartStop(disableStart = false) {\n    $('#start-button').prop('disabled', disableStart);\n    $('#stop-button').attr(\"disabled\", !disableStart);\n}\n\nfunction showError(message) {\n    $('#error').html('<i class=\"fa fa-times-circle\"></i> ' + message);\n    $('#error').show();\n}\n\nfunction convertAudioToBinaryMessage(audioChunk) {\n    console.log(\"start convertAudioToBinaryMessage\");\n    let raw = mic.toRaw(audioChunk);\n\n    if (raw == null) {\n        console(\"raw null\");\n        return;\n    }\n\n    console.log(\"raw not null\");\n    // downsample and convert the raw audio bytes to PCM\n    let downsampledBuffer = audioUtils.downsampleBuffer(raw, sampleRate);\n    let pcmEncodedBuffer = audioUtils.pcmEncode(downsampledBuffer);\n\n    // add the right JSON headers and structure to the message\n    let audioEventMessage = getAudioEventMessage(Buffer.from(pcmEncodedBuffer));\n    //console.log('audioeventmessage: ', audioEventMessage);\n\n    //convert the JSON object + headers into a binary event stream message\n    let binary = eventStreamMarshaller.marshall(audioEventMessage);\n    //console.log(\"binary :\", binary);\n    return binary;\n}\n\nfunction getAudioEventMessage(buffer) {\n    // wrap the audio data in a JSON envelope\n    return {\n        headers: {\n            ':message-type': {\n                type: 'string',\n                value: 'event'\n            },\n            ':event-type': {\n                type: 'string',\n                value: 'AudioEvent'\n            }\n        },\n        body: buffer\n    };\n}\n\nfunction createPresignedUrl() {\n    let endpoint = \"transcribestreaming.\" + region + \".amazonaws.com:8443\";\n\n    // get a preauthenticated URL that we can use to establish our WebSocket\n    return v4.createPresignedURL(\n        'GET',\n        endpoint,\n        '/stream-transcription-websocket',\n        'transcribe',\n        crypto.createHash('sha256').update('', 'utf8').digest('hex'), {\n            'key': $('#access_id').val(),\n            'secret': $('#secret_key').val(),\n            'sessionToken': $('#session_token').val(),\n            'protocol': 'wss',\n            'expires': 15,\n            'region': region,\n            'query': \"language-code=\" + languageCode + \"&media-encoding=pcm&sample-rate=\" + sampleRate\n        }\n    );\n}\n"]},"metadata":{},"sourceType":"module"}