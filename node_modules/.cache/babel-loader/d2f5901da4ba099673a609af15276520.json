{"ast":null,"code":"const audioUtils = require('./audioUtils'); // for encoding audio data as PCM\n\n\nconst crypto = require('crypto'); // tot sign our pre-signed URL\n\n\nconst v4 = require('./aws-signature-v4'); // to generate our pre-signed URL\n\n\nconst marshaller = require(\"@aws-sdk/eventstream-marshaller\"); // for converting binary event stream messages to and from JSON\n\n\nconst util_utf8_node = require(\"@aws-sdk/util-utf8-node\"); // utilities for encoding and decoding UTF8\n\n\nconst mic = require('microphone-stream'); // collect microphone input as a stream of raw bytes\n\n\nconst $ = require('jquery'); // our converter between binary event streams messages and JSON\n\n\nconst eventStreamMarshaller = new marshaller.EventStreamMarshaller(util_utf8_node.toUtf8, util_utf8_node.fromUtf8); // our global variables for managing state\n\nlet languageCode;\nlet region;\nlet sampleRate;\nlet transcription = \"\";\nlet socket;\nlet micStream;\nlet socketError = false;\nlet transcribeException = false; // check to see if the browser allows mic access\n\nif (!window.navigator.mediaDevices.getUserMedia) {\n  // Use our helper method to show an error on the page\n  showError('We support the latest versions of Chrome, Firefox, Safari, and Edge. Update your browser and try your request again.'); // maintain enabled/distabled state for the start and stop buttons\n\n  toggleStartStop();\n}\n\nexport function startbutton() {\n  console.log(\"buttontest1\");\n  toggleStartStop(true); // disable start and enable stop button\n  // set the language and region from the dropdowns\n\n  setLanguage();\n  setRegion(); // first we get the microphone input from the browser (as a promise)...\n\n  window.navigator.mediaDevices.getUserMedia({\n    video: false,\n    audio: true\n  }).then(streamAudioToWebSocket) // ...then we convert the mic stream to binary event stream messages when the promise resolves \n  .catch(function (error) {\n    showError('There was an error streaming your audio to Amazon Transcribe. Please try again.');\n    toggleStartStop();\n  });\n}\n;\n\nlet streamAudioToWebSocket = function (userMediaStream) {\n  //let's get the mic input from the browser, via the microphone-stream module\n  console.log(\"streamAudioToWebSocket\");\n  micStream = new mic();\n  micStream.setStream(userMediaStream);\n  console.log(\"buttontest2\"); // Pre-signed URLs are a way to authenticate a request (or WebSocket connection, in this case)\n  // via Query Parameters. Learn more: https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html\n\n  let url = createPresignedUrl(); //open up our WebSocket connection\n\n  socket = new WebSocket(url);\n  socket.binaryType = \"arraybuffer\"; // when we get audio data from the mic, send it to the WebSocket if possible\n\n  socket.onopen = function () {\n    console.log(\"micstream.on test\");\n\n    try {\n      micStream.on('data', function (rawAudioChunk) {\n        // the audio stream is raw audio bytes. Transcribe expects PCM with additional metadata, encoded as binary\n        let binary = convertAudioToBinaryMessage(rawAudioChunk);\n\n        if (socket.OPEN) {\n          console.log(\"socket\");\n          socket.send(binary);\n        }\n\n        ;\n      });\n    } catch (err) {\n      console.log(err);\n    }\n  }; // handle messages, errors, and close events\n\n\n  wireSocketEvents();\n};\n\nfunction setLanguage() {\n  languageCode = $('#language').find(':selected').val();\n  if (languageCode == \"en-US\" || languageCode == \"es-US\") sampleRate = 44100;else sampleRate = 44100;\n}\n\nfunction setRegion() {\n  //region = $('#region').find(':selected').val();\n  region = 'us-east-1';\n}\n\nfunction wireSocketEvents() {\n  console.log(\"wiresocketEvent test\"); // handle inbound messages from Amazon Transcribe\n\n  socket.onmessage = function (message) {\n    //convert the binary event stream message to JSON\n    let messageWrapper = eventStreamMarshaller.unmarshall(Buffer(message.data));\n    console.log(\"messageWrapper\", messageWrapper);\n    let messageBody = JSON.parse(String.fromCharCode.apply(String, messageWrapper.body));\n    console.log(\"headers: \", messageWrapper.headers[\":message-type\"].value);\n\n    if (messageWrapper.headers[\":message-type\"].value === \"event\") {\n      console.log(\"messageWrapper.headers\");\n      handleEventStreamMessage(messageBody);\n    } else {\n      console.log(\"messageWrapper.error\");\n      transcribeException = true;\n      showError(messageBody.Message);\n      toggleStartStop();\n    }\n  };\n\n  socket.onerror = function () {\n    socketError = true;\n    showError('WebSocket connection error. Try again.');\n    console.log(\"WebSocket connection error. Try again.\");\n    toggleStartStop();\n  };\n\n  socket.onclose = function (closeEvent) {\n    console.log(\"micStream.stop\");\n    micStream.stop(); // the close event immediately follows the error event; only handle one.\n\n    if (!socketError && !transcribeException) {\n      if (closeEvent.code != 1000) {\n        showError('</i><strong>Streaming Exception</strong><br>' + closeEvent.reason);\n      }\n\n      toggleStartStop();\n    }\n  };\n}\n\nlet handleEventStreamMessage = function (messageJson) {\n  let results = messageJson.Transcript.Results;\n\n  if (results.length > 0) {\n    if (results[0].Alternatives.length > 0) {\n      let transcript = results[0].Alternatives[0].Transcript; // fix encoding for accented characters\n\n      transcript = decodeURIComponent(escape(transcript)); // update the textarea with the latest result\n\n      $('#transcript').val(transcription + transcript + \"\\n\"); // if this transcript segment is final, add it to the overall transcription\n\n      if (!results[0].IsPartial) {\n        //scroll the textarea down\n        $('#transcript').scrollTop($('#transcript')[0].scrollHeight);\n        transcription += transcript + \"\\n\";\n      }\n    }\n  }\n};\n\nlet closeSocket = function () {\n  if (socket.OPEN) {\n    micStream.stop(); // Send an empty frame so that Transcribe initiates a closure of the WebSocket after submitting all transcripts\n\n    let emptyMessage = getAudioEventMessage(Buffer.from(new Buffer([])));\n    let emptyBuffer = eventStreamMarshaller.marshall(emptyMessage);\n    socket.send(emptyBuffer);\n  }\n};\n\n$('#stop-button').click(function () {\n  closeSocket();\n  toggleStartStop();\n});\n$('#reset-button').click(function () {\n  $('#transcript').val('');\n  transcription = '';\n});\n\nfunction toggleStartStop(disableStart = false) {\n  $('#start-button').prop('disabled', disableStart);\n  $('#stop-button').attr(\"disabled\", !disableStart);\n}\n\nfunction showError(message) {\n  $('#error').html('<i class=\"fa fa-times-circle\"></i> ' + message);\n  $('#error').show();\n}\n\nfunction convertAudioToBinaryMessage(audioChunk) {\n  let raw = mic.toRaw(audioChunk);\n  if (raw == null) return; // downsample and convert the raw audio bytes to PCM\n\n  let downsampledBuffer = audioUtils.downsampleBuffer(raw, sampleRate);\n  let pcmEncodedBuffer = audioUtils.pcmEncode(downsampledBuffer); // add the right JSON headers and structure to the message\n\n  let audioEventMessage = getAudioEventMessage(Buffer.from(pcmEncodedBuffer)); //convert the JSON object + headers into a binary event stream message\n\n  let binary = eventStreamMarshaller.marshall(audioEventMessage);\n  return binary;\n}\n\nfunction getAudioEventMessage(buffer) {\n  // wrap the audio data in a JSON envelope\n  return {\n    headers: {\n      ':message-type': {\n        type: 'string',\n        value: 'event'\n      },\n      ':event-type': {\n        type: 'string',\n        value: 'AudioEvent'\n      }\n    },\n    body: buffer\n  };\n}\n\nfunction createPresignedUrl() {\n  let endpoint = \"transcribestreaming.\" + region + \".amazonaws.com:8443\"; // get a preauthenticated URL that we can use to establish our WebSocket\n\n  return v4.createPresignedURL('GET', endpoint, '/stream-transcription-websocket', 'transcribe', crypto.createHash('sha256').update('', 'utf8').digest('hex'), {\n    'key': $('#access_id').val(),\n    'secret': $('#secret_key').val(),\n    'sessionToken': $('#session_token').val(),\n    'protocol': 'wss',\n    'expires': 15,\n    'region': region,\n    'query': \"language-code=\" + languageCode + \"&media-encoding=pcm&sample-rate=\" + sampleRate\n  });\n}","map":{"version":3,"sources":["/home/ec2-user/environment/myapp/src/lib/main.js"],"names":["audioUtils","require","crypto","v4","marshaller","util_utf8_node","mic","$","eventStreamMarshaller","EventStreamMarshaller","toUtf8","fromUtf8","languageCode","region","sampleRate","transcription","socket","micStream","socketError","transcribeException","window","navigator","mediaDevices","getUserMedia","showError","toggleStartStop","startbutton","console","log","setLanguage","setRegion","video","audio","then","streamAudioToWebSocket","catch","error","userMediaStream","setStream","url","createPresignedUrl","WebSocket","binaryType","onopen","on","rawAudioChunk","binary","convertAudioToBinaryMessage","OPEN","send","err","wireSocketEvents","find","val","onmessage","message","messageWrapper","unmarshall","Buffer","data","messageBody","JSON","parse","String","fromCharCode","apply","body","headers","value","handleEventStreamMessage","Message","onerror","onclose","closeEvent","stop","code","reason","messageJson","results","Transcript","Results","length","Alternatives","transcript","decodeURIComponent","escape","IsPartial","scrollTop","scrollHeight","closeSocket","emptyMessage","getAudioEventMessage","from","emptyBuffer","marshall","click","disableStart","prop","attr","html","show","audioChunk","raw","toRaw","downsampledBuffer","downsampleBuffer","pcmEncodedBuffer","pcmEncode","audioEventMessage","buffer","type","endpoint","createPresignedURL","createHash","update","digest"],"mappings":"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","sourcesContent":["const audioUtils        = require('./audioUtils');  // for encoding audio data as PCM\nconst crypto            = require('crypto'); // tot sign our pre-signed URL\nconst v4                = require('./aws-signature-v4'); // to generate our pre-signed URL\nconst marshaller        = require(\"@aws-sdk/eventstream-marshaller\"); // for converting binary event stream messages to and from JSON\nconst util_utf8_node    = require(\"@aws-sdk/util-utf8-node\"); // utilities for encoding and decoding UTF8\nconst mic               = require('microphone-stream'); // collect microphone input as a stream of raw bytes\nconst $                 = require('jquery');\n\n// our converter between binary event streams messages and JSON\nconst eventStreamMarshaller = new marshaller.EventStreamMarshaller(util_utf8_node.toUtf8, util_utf8_node.fromUtf8);\n\n// our global variables for managing state\nlet languageCode;\nlet region;\nlet sampleRate;\nlet transcription = \"\";\nlet socket;\nlet micStream;\nlet socketError = false;\nlet transcribeException = false;\n\n\n// check to see if the browser allows mic access\nif (!window.navigator.mediaDevices.getUserMedia) {\n    // Use our helper method to show an error on the page\n    showError('We support the latest versions of Chrome, Firefox, Safari, and Edge. Update your browser and try your request again.');\n\n    // maintain enabled/distabled state for the start and stop buttons\n    toggleStartStop();\n}\n\n    export function startbutton () {\n    console.log(\"buttontest1\");\n    toggleStartStop(true); // disable start and enable stop button\n\n    // set the language and region from the dropdowns\n    setLanguage();\n    setRegion();\n\n    // first we get the microphone input from the browser (as a promise)...\n    window.navigator.mediaDevices.getUserMedia({ video: false, audio: true }).then(streamAudioToWebSocket)\n        // ...then we convert the mic stream to binary event stream messages when the promise resolves \n        .catch(function (error) {\n            showError('There was an error streaming your audio to Amazon Transcribe. Please try again.');\n            toggleStartStop();\n        });\n};\n\nlet streamAudioToWebSocket = function (userMediaStream) {\n    //let's get the mic input from the browser, via the microphone-stream module\n    console.log(\"streamAudioToWebSocket\");\n    micStream = new mic();\n    micStream.setStream(userMediaStream);\n    console.log(\"buttontest2\");\n\n    // Pre-signed URLs are a way to authenticate a request (or WebSocket connection, in this case)\n    // via Query Parameters. Learn more: https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html\n    let url = createPresignedUrl();\n\n    //open up our WebSocket connection\n    socket = new WebSocket(url);\n    socket.binaryType = \"arraybuffer\";\n\n    // when we get audio data from the mic, send it to the WebSocket if possible\n    socket.onopen = function() {\n        console.log(\"micstream.on test\");\n        try{\n        micStream.on('data', function(rawAudioChunk) {\n            // the audio stream is raw audio bytes. Transcribe expects PCM with additional metadata, encoded as binary\n            let binary = convertAudioToBinaryMessage(rawAudioChunk);\n\n            if (socket.OPEN) {\n                console.log(\"socket\");\n                socket.send(binary);\n            };\n        }\n    )\n        } catch (err) {\n        console.log(err);\n      }\n        };\n\n    // handle messages, errors, and close events\n    wireSocketEvents();\n}\n\nfunction setLanguage() {\n    languageCode = $('#language').find(':selected').val();\n    if (languageCode == \"en-US\" || languageCode == \"es-US\")\n        sampleRate = 44100;\n    else\n        sampleRate = 44100;\n}\n\nfunction setRegion() {\n    //region = $('#region').find(':selected').val();\n    region = 'us-east-1';\n}\n\nfunction wireSocketEvents() {\n    console.log(\"wiresocketEvent test\");\n    // handle inbound messages from Amazon Transcribe\n    socket.onmessage = function (message) {\n        //convert the binary event stream message to JSON\n        let messageWrapper = eventStreamMarshaller.unmarshall(Buffer(message.data));\n        console.log(\"messageWrapper\", messageWrapper);\n        let messageBody = JSON.parse(String.fromCharCode.apply(String, messageWrapper.body));\n        console.log(\"headers: \", messageWrapper.headers[\":message-type\"].value);\n        if (messageWrapper.headers[\":message-type\"].value === \"event\") {\n            console.log(\"messageWrapper.headers\");\n            handleEventStreamMessage(messageBody);\n        }\n        else {\n            console.log(\"messageWrapper.error\");\n            transcribeException = true;\n            showError(messageBody.Message);\n            toggleStartStop();\n        }\n    };\n\n    socket.onerror = function () {\n        socketError = true;\n        showError('WebSocket connection error. Try again.');\n        console.log(\"WebSocket connection error. Try again.\");\n        toggleStartStop();\n    };\n    \n    socket.onclose = function (closeEvent) {\n        console.log(\"micStream.stop\");\n        micStream.stop();\n        \n        // the close event immediately follows the error event; only handle one.\n        if (!socketError && !transcribeException) {\n            if (closeEvent.code != 1000) {\n                showError('</i><strong>Streaming Exception</strong><br>' + closeEvent.reason);\n            }\n            toggleStartStop();\n        }\n    };\n}\n\nlet handleEventStreamMessage = function (messageJson) {\n    let results = messageJson.Transcript.Results;\n\n    if (results.length > 0) {\n        if (results[0].Alternatives.length > 0) {\n            let transcript = results[0].Alternatives[0].Transcript;\n\n            // fix encoding for accented characters\n            transcript = decodeURIComponent(escape(transcript));\n\n            // update the textarea with the latest result\n            $('#transcript').val(transcription + transcript + \"\\n\");\n\n            // if this transcript segment is final, add it to the overall transcription\n            if (!results[0].IsPartial) {\n                //scroll the textarea down\n                $('#transcript').scrollTop($('#transcript')[0].scrollHeight);\n\n                transcription += transcript + \"\\n\";\n            }\n        }\n    }\n}\n\nlet closeSocket = function () {\n    if (socket.OPEN) {\n        micStream.stop();\n\n        // Send an empty frame so that Transcribe initiates a closure of the WebSocket after submitting all transcripts\n        let emptyMessage = getAudioEventMessage(Buffer.from(new Buffer([])));\n        let emptyBuffer = eventStreamMarshaller.marshall(emptyMessage);\n        socket.send(emptyBuffer);\n    }\n}\n\n$('#stop-button').click(function () {\n    closeSocket();\n    toggleStartStop();\n});\n\n$('#reset-button').click(function (){\n    $('#transcript').val('');\n    transcription = '';\n});\n\nfunction toggleStartStop(disableStart = false) {\n    $('#start-button').prop('disabled', disableStart);\n    $('#stop-button').attr(\"disabled\", !disableStart);\n}\n\nfunction showError(message) {\n    $('#error').html('<i class=\"fa fa-times-circle\"></i> ' + message);\n    $('#error').show();\n}\n\nfunction convertAudioToBinaryMessage(audioChunk) {\n    let raw = mic.toRaw(audioChunk);\n\n    if (raw == null)\n        return;\n\n    // downsample and convert the raw audio bytes to PCM\n    let downsampledBuffer = audioUtils.downsampleBuffer(raw, sampleRate);\n    let pcmEncodedBuffer = audioUtils.pcmEncode(downsampledBuffer);\n\n    // add the right JSON headers and structure to the message\n    let audioEventMessage = getAudioEventMessage(Buffer.from(pcmEncodedBuffer));\n\n    //convert the JSON object + headers into a binary event stream message\n    let binary = eventStreamMarshaller.marshall(audioEventMessage);\n\n    return binary;\n}\n\nfunction getAudioEventMessage(buffer) {\n    // wrap the audio data in a JSON envelope\n    return {\n        headers: {\n            ':message-type': {\n                type: 'string',\n                value: 'event'\n            },\n            ':event-type': {\n                type: 'string',\n                value: 'AudioEvent'\n            }\n        },\n        body: buffer\n    };\n}\n\nfunction createPresignedUrl() {\n    let endpoint = \"transcribestreaming.\" + region + \".amazonaws.com:8443\";\n\n    // get a preauthenticated URL that we can use to establish our WebSocket\n    return v4.createPresignedURL(\n        'GET',\n        endpoint,\n        '/stream-transcription-websocket',\n        'transcribe',\n        crypto.createHash('sha256').update('', 'utf8').digest('hex'), {\n            'key': $('#access_id').val(),\n            'secret': $('#secret_key').val(),\n            'sessionToken': $('#session_token').val(),\n            'protocol': 'wss',\n            'expires': 15,\n            'region': region,\n            'query': \"language-code=\" + languageCode + \"&media-encoding=pcm&sample-rate=\" + sampleRate\n        }\n    );\n}\n"]},"metadata":{},"sourceType":"module"}